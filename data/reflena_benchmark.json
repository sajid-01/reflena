{
  "benchmark": "reflena-scientific-v1",
  "problems": [
        {
        "problem": "black_scholes_call_price",
        "function_name": "bs_call_price",
        "signature": "S, K, r, T, sigma",
        "description": "Compute the Black–Scholes price of a European call option.",
        "cases": [
            {
            "type": "core",
            "input": { "S": 100.0, "K": 100.0, "r": 0.05, "T": 1.0, "sigma": 0.2 },
            "output": 10.45
            },
            {
            "type": "noisy",
            "input": { "S": 102.0, "K": 100.0, "r": 0.048, "T": 0.95, "sigma": 0.21 },
            "output": 11.3
            }
        ],
        "tolerance": 0.15
        },
        {
        "problem": "implied_volatility_newton",
        "function_name": "implied_volatility",
        "signature": "price, S, K, r, T",
        "description": "Estimate implied volatility of a European call option using Newton–Raphson iteration.",
        "cases": [
            {
            "type": "core",
            "input": { "price": 10.45, "S": 100.0, "K": 100.0, "r": 0.05, "T": 1.0 },
            "output": 0.2
            }
        ],
        "tolerance": 0.02
        },
        {
        "problem": "monte_carlo_option_pricing",
        "function_name": "mc_call_price",
        "signature": "S, K, r, T, sigma, n_paths",
        "description": "Estimate the European call option price using Monte Carlo simulation under geometric Brownian motion.",
        "cases": [
            {
            "type": "core",
            "input": {
                "S": 100.0,
                "K": 100.0,
                "r": 0.05,
                "T": 1.0,
                "sigma": 0.2,
                "n_paths": 50000
            },
            "output": 10.4
            }
        ],
        "tolerance": 0.5
        },
        {
        "problem": "portfolio_variance",
        "function_name": "portfolio_variance",
        "signature": "weights, cov",
        "description": "Compute portfolio variance given asset weights and covariance matrix.",
        "cases": [
            {
            "type": "core",
            "input": {
                "weights": [0.4, 0.6],
                "cov": [[0.04, 0.006], [0.006, 0.09]]
            },
            "output": 0.047
            }
        ],
        "tolerance": 0.002
        },
        {
        "problem": "value_at_risk_gaussian",
        "function_name": "value_at_risk",
        "signature": "mu, sigma, alpha",
        "description": "Compute Value-at-Risk (VaR) under a Gaussian return assumption.",
        "cases": [
            {
            "type": "core",
            "input": { "mu": 0.001, "sigma": 0.02, "alpha": 0.05 },
            "output": -0.0329
            }
        ],
        "tolerance": 0.002
        }







    ,{
        "problem": "michaelis_menten_rate",
        "function_name": "reaction_rate",
        "signature": "Vmax, Km, S",
        "description": "Compute the reaction velocity using the Michaelis–Menten equation for enzyme kinetics.",
        "cases": [
            {
            "type": "core",
            "input": { "Vmax": 1.5, "Km": 0.3, "S": 0.5 },
            "output": 0.9375
            },
            {
            "type": "noisy",
            "input": { "Vmax": 1.52, "Km": 0.29, "S": 0.48 },
            "output": 0.96
            }
        ],
        "tolerance": 0.02
        },
        {
        "problem": "competitive_inhibition_rate",
        "function_name": "competitive_inhibition_rate",
        "signature": "Vmax, Km, S, I, Ki",
        "description": "Compute reaction velocity for a competitively inhibited enzyme system.",
        "cases": [
            {
            "type": "core",
            "input": {
                "Vmax": 2.0,
                "Km": 0.5,
                "S": 0.6,
                "I": 0.4,
                "Ki": 0.2
            },
            "output": 0.7059
            }
        ],
        "tolerance": 0.02
        },
        {
        "problem": "gibbs_free_energy",
        "function_name": "gibbs_energy",
        "signature": "delta_H, delta_S, T",
        "description": "Compute the Gibbs free energy change ΔG = ΔH − TΔS for a biochemical reaction.",
        "cases": [
            {
            "type": "core",
            "input": {
                "delta_H": -40.0,
                "delta_S": -0.1,
                "T": 298.15
            },
            "output": -10.185
            }
        ],
        "tolerance": 0.1
        },
        {
        "problem": "ligand_binding_fraction",
        "function_name": "binding_fraction",
        "signature": "L, Kd",
        "description": "Compute the fraction of occupied binding sites given ligand concentration and dissociation constant.",
        "cases": [
            {
            "type": "core",
            "input": { "L": 2.0, "Kd": 0.5 },
            "output": 0.8
            },
            {
            "type": "noisy",
            "input": { "L": 1.8, "Kd": 0.55 },
            "output": 0.77
            }
        ],
        "tolerance": 0.03
        },
        {
        "problem": "hill_equation_cooperativity",
        "function_name": "hill_fraction",
        "signature": "L, Kd, n",
        "description": "Compute binding fraction using the Hill equation to model cooperative binding.",
        "cases": [
            {
            "type": "core",
            "input": {
                "L": 1.5,
                "Kd": 1.0,
                "n": 2
            },
            "output": 0.692
            }
        ],
        "tolerance": 0.02
        }




    ,{
        "problem": "spectral_radius_power_iteration",
        "function_name": "spectral_radius",
        "signature": "A, num_iter",
        "description": "Estimate the spectral radius (largest absolute eigenvalue) of a square matrix using the power iteration method.",
        "cases": [
            {
            "type": "core",
            "input": {
                "A": [[4, 1], [2, 3]],
                "num_iter": 50
            },
            "output": 5.0
            },
            {
            "type": "noisy",
            "input": {
                "A": [[4.001, 1], [2, 2.999]],
                "num_iter": 60
            },
            "output": 5.0
            }
        ],
        "tolerance": 1e-2
        },
        {
        "problem": "condition_number_2norm",
        "function_name": "condition_number",
        "signature": "A",
        "description": "Compute the condition number of a matrix using the 2-norm definition.",
        "cases": [
            {
            "type": "core",
            "input": {
                "A": [[1, 2], [3, 4]]
            },
            "output": 14.93
            }
        ],
        "tolerance": 0.5
        },
        {
        "problem": "least_squares_solution",
        "function_name": "least_squares",
        "signature": "A, b",
        "description": "Solve an overdetermined linear system in the least-squares sense using normal equations.",
        "cases": [
            {
            "type": "core",
            "input": {
                "A": [[1, 1], [1, 2], [1, 3]],
                "b": [1, 2, 2]
            },
            "output": [0.6667, 0.5]
            }
        ],
        "tolerance": 1e-2
        },
        {
        "problem": "qr_orthogonality_error",
        "function_name": "qr_orthogonality_error",
        "signature": "Q",
        "description": "Compute the Frobenius norm of (QᵀQ − I) to assess loss of orthogonality in a QR factor.",
        "cases": [
            {
            "type": "core",
            "input": {
                "Q": [[0.7071, 0.7071], [0.7071, -0.7071]]
            },
            "output": 0.0
            },
            {
            "type": "noisy",
            "input": {
                "Q": [[0.7072, 0.7070], [0.7070, -0.7072]]
            },
            "output": 1e-3
            }
        ],
        "tolerance": 2e-3
        },
        {
        "problem": "matrix_exponential_trace",
        "function_name": "matrix_exponential_trace",
        "signature": "A",
        "description": "Approximate the trace of exp(A) for a 2×2 matrix using a truncated Taylor series.",
        "cases": [
            {
            "type": "core",
            "input": {
                "A": [[0, 1], [-1, 0]]
            },
            "output": 2.0
            }
        ],
        "tolerance": 1e-2
        },



    {
        "problem": "kepler_orbital_period",
        "function_name": "orbital_period",
        "signature": "a, M, G",
        "description": "Compute the orbital period of a body using Kepler’s third law for a circular orbit.",
        "cases": [
            {
            "type": "core",
            "input": { "a": 1.5e11, "M": 1.989e30, "G": 6.67430e-11 },
            "output": 3.1557e7
            },
            {
            "type": "noisy",
            "input": { "a": 1.49e11, "M": 1.989e30, "G": 6.67430e-11 },
            "output": 3.13e7
            }
        ],
        "tolerance": 5e5
        },
        {
        "problem": "escape_velocity",
        "function_name": "escape_velocity",
        "signature": "M, r, G",
        "description": "Compute the escape velocity from a spherical body using Newtonian gravity.",
        "cases": [
            {
            "type": "core",
            "input": { "M": 5.972e24, "r": 6.371e6, "G": 6.67430e-11 },
            "output": 11186.0
            }
        ],
        "tolerance": 50.0
        },
        {
        "problem": "schwarzschild_radius",
        "function_name": "schwarzschild_radius",
        "signature": "M, G, c",
        "description": "Compute the Schwarzschild radius of a non-rotating black hole.",
        "cases": [
            {
            "type": "core",
            "input": { "M": 1.989e30, "G": 6.67430e-11, "c": 2.998e8 },
            "output": 2953.0
            }
        ],
        "tolerance": 5.0
        },
        {
        "problem": "stellar_luminosity",
        "function_name": "stellar_luminosity",
        "signature": "R, T, sigma",
        "description": "Compute the luminosity of a star using the Stefan–Boltzmann law.",
        "cases": [
            {
            "type": "core",
            "input": { "R": 6.96e8, "T": 5778, "sigma": 5.670374419e-8 },
            "output": 3.83e26
            },
            {
            "type": "noisy",
            "input": { "R": 6.95e8, "T": 5800, "sigma": 5.670374419e-8 },
            "output": 3.85e26
            }
        ],
        "tolerance": 5e24
        },
        {
        "problem": "hubble_recession_velocity",
        "function_name": "recession_velocity",
        "signature": "distance, H0",
        "description": "Compute the recession velocity of a galaxy using Hubble’s law.",
        "cases": [
            {
            "type": "core",
            "input": { "distance": 1.0e22, "H0": 2.27e-18 },
            "output": 2.27e4
            }
        ],
        "tolerance": 500.0
        },

    {
        "problem": "arrhenius_rate_constant",
        "function_name": "arrhenius_rate",
        "signature": "A, Ea, T, R",
        "description": "Compute the Arrhenius reaction rate constant k(T)=A*exp(-Ea/(R*T)).",
        "cases": [
            {
            "type": "core",
            "input": { "A": 1e13, "Ea": 80000, "T": 298, "R": 8.314 },
            "output": 2.646e-02
            },
            {
            "type": "noisy",
            "input": { "A": 1.01e13, "Ea": 79900, "T": 300, "R": 8.314 },
            "output": 4.44e-02
            }
        ],
        "tolerance": 1e-3
        },
        {
        "problem": "equilibrium_extent",
        "function_name": "equilibrium_extent",
        "signature": "nA0, nB0, K",
        "description": "Compute equilibrium extent xi for A ⇌ B given initial moles and equilibrium constant.",
        "cases": [
            {
            "type": "core",
            "input": { "nA0": 1.0, "nB0": 0.0, "K": 10.0 },
            "output": 0.9091
            }
        ],
        "tolerance": 1e-3
        },
        {
        "problem": "beer_lambert_concentration",
        "function_name": "concentration",
        "signature": "absorbances, epsilon, path_length",
        "description": "Compute solute concentration using Beer–Lambert law from noisy absorbance measurements.",
        "cases": [
            {
            "type": "core",
            "input": { "absorbances": [0.51, 0.49, 0.50], "epsilon": 1000, "path_length": 1.0 },
            "output": 0.0005
            }
        ],
        "tolerance": 1e-5
        },
        {
        "problem": "nernst_potential",
        "function_name": "nernst_potential",
        "signature": "E0, Q, T, n, R, F",
        "description": "Compute electrode potential using the Nernst equation.",
        "cases": [
            {
            "type": "core",
            "input": { "E0": 1.10, "Q": 10.0, "T": 298, "n": 2, "R": 8.314, "F": 96485 },
            "output": 1.069
            }
        ],
        "tolerance": 1e-3
        },
        {
        "problem": "boltzmann_population_ratio",
        "function_name": "boltzmann_ratio",
        "signature": "E1, E2, T, kB",
        "description": "Compute population ratio between two energy levels using Boltzmann statistics.",
        "cases": [
            {
            "type": "core",
            "input": { "E1": 0.0, "E2": 1e-20, "T": 300, "kB": 1.38e-23 },
            "output": 0.786
            }
        ],
        "tolerance": 1e-3
    }






    ,{
      "problem": "heat_equation_1d_step",
      "function_name": "heat_step",
      "signature": "u, alpha, dx, dt",
      "description": "Simulate one explicit Euler time step of the 1D heat equation du/dt = alpha * d2u/dx2 on a uniform grid.",
      "inputs_description": {
        "u": "Temperature values on a 1D grid",
        "alpha": "Thermal diffusivity (>0)",
        "dx": "Grid spacing (>0)",
        "dt": "Time step (>0)"
      },
      "output_description": "Updated temperature field after one time step",
      "cases": [
        {
          "type": "core",
          "input": { "u": [1, 2, 3, 2, 1], "alpha": 1.0, "dx": 1.0, "dt": 0.1 },
          "output": [1.0, 1.8, 2.6, 1.8, 1.0]
        },
        {
          "type": "edge",
          "input": { "u": [5.0], "alpha": 1.0, "dx": 1.0, "dt": 0.1 },
          "output": [5.0]
        },
        {
          "type": "noisy",
          "input": { "u": [1.0001, 1.9998, 3.0002, 2.0001, 0.9999], "alpha": 0.999, "dx": 1.001, "dt": 0.099 },
          "output": [1.0001, 1.7999, 2.6000, 1.8001, 0.9999]
        }
      ],
      "tolerance": 1e-6
    },

    {
      "problem": "ray_triangle_intersection",
      "function_name": "ray_intersects_triangle",
      "signature": "ray_origin, ray_dir, v0, v1, v2",
      "description": "Determine whether a ray intersects a triangle in 3D using robust geometric testing.",
      "cases": [
        {
          "type": "core",
          "input": {
            "ray_origin": [0, 0, -1],
            "ray_dir": [0, 0, 1],
            "v0": [0,0,0], "v1": [1,0,0], "v2": [0,1,0]
          },
          "output": true
        },
        {
          "type": "edge",
          "input": {
            "ray_origin": [0.2, 0.2, 0],
            "ray_dir": [0, 0, 1],
            "v0": [0,0,0], "v1": [1,0,0], "v2": [0,1,0]
          },
          "output": false
        }
      ],
      "tolerance": 0.0
    },

    {
      "problem": "dominant_eigenvalue",
      "function_name": "dominant_eigenvalue",
      "signature": "A, num_iters",
      "description": "Compute the dominant eigenvalue of a real symmetric matrix using power iteration.",
      "cases": [
        {
          "type": "core",
          "input": { "A": [[3,1],[1,3]], "num_iters": 30 },
          "output": 4.0
        },
        {
          "type": "edge",
          "input": { "A": [[1,0],[0,1]], "num_iters": 15 },
          "output": 1.0
        }
      ],
      "tolerance": 1e-4
    },

    {
      "problem": "quantum_probability_flux",
      "function_name": "probability_flux",
      "signature": "psi_real, psi_imag, dx, hbar, m",
      "description": "Compute the probability flux j(x) = (hbar/m) * Im(psi*grad psi) in 1D.",
      "cases": [
        {
          "type": "core",
          "input": {
            "psi_real": [1,0,-1],
            "psi_imag": [0,1,0],
            "dx": 1.0, "hbar": 1.0, "m": 1.0
          },
          "output": [0.0, -1.0, 0.0]
        },
        {
          "type": "edge",
          "input": {
            "psi_real": [1,1,1],
            "psi_imag": [0,0,0],
            "dx": 1.0, "hbar": 1.0, "m": 1.0
          },
          "output": [0.0,0.0,0.0]
        }
      ],
      "tolerance": 1e-6
    },

    {
      "problem": "newton_root",
      "function_name": "newton_root",
      "signature": "x0, num_iters",
      "description": "Find a root of f(x)=x^3-x-2 using Newton–Raphson iteration.",
      "cases": [
        {
          "type": "core",
          "input": { "x0": 1.5, "num_iters": 10 },
          "output": 1.5213797
        },
        {
          "type": "edge",
          "input": { "x0": -10.0, "num_iters": 20 },
          "output": 1.5213797
        }
      ],
      "tolerance": 1e-5
    },

    {
        "problem": "fraunhofer_single_slit_intensity",
        "function_name": "single_slit_intensity",
        "signature": "a, wavelength, theta",
        "description": "Compute normalized Fraunhofer diffraction intensity for a single slit.",
        "cases": [
            {
            "type": "core",
            "input": {
                "a": 1e-4,
                "wavelength": 500e-9,
                "theta": 0.0
            },
            "output": 1.0
            },
            {
            "type": "noisy",
            "input": {
                "a": 1e-4,
                "wavelength": 500e-9,
                "theta": 0.01
            },
            "output": 0.93
            }
        ],
        "tolerance": 0.05
        },
        {
        "problem": "double_slit_interference_intensity",
        "function_name": "double_slit_intensity",
        "signature": "d, a, wavelength, theta",
        "description": "Compute normalized Fraunhofer diffraction intensity for a double slit.",
        "cases": [
            {
            "type": "core",
            "input": {
                "d": 3e-4,
                "a": 1e-4,
                "wavelength": 600e-9,
                "theta": 0.0
            },
            "output": 1.0
            }
        ],
        "tolerance": 0.05
        },
        {
        "problem": "brewster_angle",
        "function_name": "brewster_angle",
        "signature": "n1, n2",
        "description": "Compute the Brewster angle for light incident from medium n1 into n2.",
        "cases": [
            {
            "type": "core",
            "input": {
                "n1": 1.0,
                "n2": 1.5
            },
            "output": 0.9828
            }
        ],
        "tolerance": 0.01
        },
        {
        "problem": "fresnel_reflectance_unpolarized",
        "function_name": "fresnel_reflectance",
        "signature": "n1, n2, theta_i",
        "description": "Compute Fresnel reflectance for unpolarized light at an interface.",
        "cases": [
            {
            "type": "core",
            "input": {
                "n1": 1.0,
                "n2": 1.5,
                "theta_i": 0.0
            },
            "output": 0.04
            }
        ],
        "tolerance": 0.01
        },
        {
        "problem": "gaussian_beam_waist_evolution",
        "function_name": "beam_waist",
        "signature": "w0, wavelength, z",
        "description": "Compute Gaussian beam waist as a function of propagation distance.",
        "cases": [
            {
            "type": "core",
            "input": {
                "w0": 1e-3,
                "wavelength": 632.8e-9,
                "z": 0.0
            },
            "output": 1e-3
            },
            {
            "type": "noisy",
            "input": {
                "w0": 1e-3,
                "wavelength": 632.8e-9,
                "z": 0.5
            },
            "output": 0.0011
            }
        ],
        "tolerance": 2e-4
    },

    {
        "problem": "logistic_growth_solution",
        "function_name": "logistic_population",
        "signature": "r, K, P0, t",
        "description": "Compute population size at time t under logistic growth dynamics.",
        "cases": [
            {
            "type": "core",
            "input": {
                "r": 0.5,
                "K": 1000.0,
                "P0": 50.0,
                "t": 10.0
            },
            "output": 882.5
            }
        ],
        "tolerance": 5.0
        },
        {
        "problem": "lotka_volterra_equilibrium",
        "function_name": "predator_prey_equilibrium",
        "signature": "alpha, beta, delta, gamma",
        "description": "Compute the non-trivial equilibrium populations of a Lotka–Volterra predator–prey system.",
        "cases": [
            {
            "type": "core",
            "input": {
                "alpha": 1.0,
                "beta": 0.1,
                "delta": 0.075,
                "gamma": 1.5
            },
            "output": [20.0, 10.0]
            }
        ],
        "tolerance": 0.5
        },
        {
        "problem": "metapopulation_persistence_threshold",
        "function_name": "persistence_threshold",
        "signature": "c, e",
        "description": "Determine whether a metapopulation persists based on colonization and extinction rates.",
        "cases": [
            {
            "type": "core",
            "input": {
                "c": 0.4,
                "e": 0.2
            },
            "output": true
            },
            {
            "type": "noisy",
            "input": {
                "c": 0.18,
                "e": 0.2
            },
            "output": false
            }
        ],
        "tolerance": 0.0
        },
        {
        "problem": "shannon_biodiversity_index",
        "function_name": "shannon_index",
        "signature": "counts",
        "description": "Compute the Shannon biodiversity index for a community given species counts.",
        "cases": [
            {
            "type": "core",
            "input": {
                "counts": [50, 25, 25]
            },
            "output": 1.0397
            }
        ],
        "tolerance": 0.02
        },
        {
        "problem": "allee_effect_population_change",
        "function_name": "allee_growth_rate",
        "signature": "r, K, A, P",
        "description": "Compute instantaneous population growth rate under a strong Allee effect.",
        "cases": [
            {
            "type": "core",
            "input": {
                "r": 0.4,
                "K": 1000.0,
                "A": 100.0,
                "P": 150.0
            },
            "output": 12.0
            }
        ],
        "tolerance": 1.0
        },

        {
            "problem": "hardy_weinberg_equilibrium",
            "function_name": "genotype_frequencies",
            "signature": "p",
            "description": "Compute genotype frequencies under Hardy–Weinberg equilibrium given allele frequency p.",
            "cases": [
                {
                "type": "core",
                "input": {
                    "p": 0.7
                },
                "output": [0.49, 0.42, 0.09]
                }
            ],
            "tolerance": 0.01
            },
            {
            "problem": "selection_allele_frequency_update",
            "function_name": "next_generation_frequency",
            "signature": "p, wAA, wAa, waa",
            "description": "Compute allele frequency in the next generation under viability selection.",
            "cases": [
                {
                "type": "core",
                "input": {
                    "p": 0.6,
                    "wAA": 1.0,
                    "wAa": 0.9,
                    "waa": 0.8
                },
                "output": 0.626
                }
            ],
            "tolerance": 0.01
            },
            {
            "problem": "mutation_selection_balance",
            "function_name": "mutation_selection_balance",
            "signature": "mu, s",
            "description": "Compute equilibrium frequency of a deleterious recessive allele under mutation–selection balance.",
            "cases": [
                {
                "type": "core",
                "input": {
                    "mu": 1e-5,
                    "s": 0.01
                },
                "output": 0.0316
                }
            ],
            "tolerance": 0.002
            },
            {
            "problem": "linkage_disequilibrium_decay",
            "function_name": "ld_decay",
            "signature": "D0, r, t",
            "description": "Compute linkage disequilibrium after t generations with recombination rate r.",
            "cases": [
                {
                "type": "core",
                "input": {
                    "D0": 0.25,
                    "r": 0.1,
                    "t": 10
                },
                "output": 0.087
                }
            ],
            "tolerance": 0.01
            },
            {
            "problem": "wright_fisher_variance",
            "function_name": "genetic_drift_variance",
            "signature": "p, N",
            "description": "Compute variance in allele frequency due to genetic drift under the Wright–Fisher model.",
            "cases": [
                {
                "type": "core",
                "input": {
                    "p": 0.5,
                    "N": 100
                },
                "output": 0.00125
                }
            ],
            "tolerance": 0.0002
        },

        {
            "problem": "bloch_vector_from_density_matrix",
            "function_name": "bloch_vector",
            "signature": "rho",
            "description": "Compute the Bloch vector (x, y, z) for a single-qubit density matrix.",
            "cases": [
                {
                "type": "core",
                "input": {
                    "rho": [[0.5, 0.5], [0.5, 0.5]]
                },
                "output": [1.0, 0.0, 0.0]
                }
            ],
            "tolerance": 0.02
            },
            {
            "problem": "von_neumann_entropy",
            "function_name": "von_neumann_entropy",
            "signature": "rho",
            "description": "Compute the von Neumann entropy of a quantum state given its density matrix.",
            "cases": [
                {
                "type": "core",
                "input": {
                    "rho": [[0.5, 0.0], [0.0, 0.5]]
                },
                "output": 0.6931
                }
            ],
            "tolerance": 0.01
            },
            {
            "problem": "bell_state_concurrence",
            "function_name": "concurrence",
            "signature": "rho",
            "description": "Compute the concurrence of a two-qubit Bell state density matrix.",
            "cases": [
                {
                "type": "core",
                "input": {
                    "rho": [
                    [0.5, 0.0, 0.0, 0.5],
                    [0.0, 0.0, 0.0, 0.0],
                    [0.0, 0.0, 0.0, 0.0],
                    [0.5, 0.0, 0.0, 0.5]
                    ]
                },
                "output": 1.0
                }
            ],
            "tolerance": 0.02
            },
            {
            "problem": "quantum_fidelity",
            "function_name": "quantum_fidelity",
            "signature": "rho, sigma",
            "description": "Compute the quantum state fidelity between two density matrices.",
            "cases": [
                {
                "type": "core",
                "input": {
                    "rho": [[1.0, 0.0], [0.0, 0.0]],
                    "sigma": [[0.5, 0.5], [0.5, 0.5]]
                },
                "output": 0.5
                }
            ],
            "tolerance": 0.02
            },
            {
            "problem": "hadamard_expectation_value",
            "function_name": "hadamard_expectation",
            "signature": "state",
            "description": "Compute the expectation value of the Hadamard operator for a single-qubit pure state vector.",
            "cases": [
                {
                "type": "core",
                "input": {
                    "state": [0.7071, 0.7071]
                },
                "output": 1.0
                }
            ],
            "tolerance": 0.02
        },

        {
            "problem": "hartree_fock_energy_two_electron",
            "function_name": "hartree_fock_energy",
            "signature": "h11, h22, J12, K12",
            "description": "Compute the Hartree–Fock total energy for a minimal two-electron system.",
            "cases": [
                {
                "type": "core",
                "input": {
                    "h11": -1.0,
                    "h22": -0.8,
                    "J12": 0.6,
                    "K12": 0.2
                },
                "output": -1.6
                }
            ],
            "tolerance": 0.05
            },
            {
            "problem": "born_oppenheimer_potential",
            "function_name": "bo_potential",
            "signature": "R, A, B",
            "description": "Compute a simplified Born–Oppenheimer potential energy curve using a Morse-like model.",
            "cases": [
                {
                "type": "core",
                "input": {
                    "R": 1.0,
                    "A": 5.0,
                    "B": 1.5
                },
                "output": 0.776
                },
                {
                "type": "noisy",
                "input": {
                    "R": 1.1,
                    "A": 5.0,
                    "B": 1.5
                },
                "output": 0.72
                }
            ],
            "tolerance": 0.05
            },
            {
            "problem": "partition_function_quantum_oscillator",
            "function_name": "quantum_partition_function",
            "signature": "omega, T, hbar, kB",
            "description": "Compute the canonical partition function of a quantum harmonic oscillator.",
            "cases": [
                {
                "type": "core",
                "input": {
                    "omega": 1.0,
                    "T": 300.0,
                    "hbar": 1.0,
                    "kB": 1.0
                },
                "output": 1.0007
                }
            ],
            "tolerance": 0.01
            },
            {
            "problem": "radial_distribution_function_peak",
            "function_name": "rdf_first_peak",
            "signature": "r, g",
            "description": "Estimate the position of the first peak of a radial distribution function.",
            "cases": [
                {
                "type": "core",
                "input": {
                    "r": [0.8, 1.0, 1.2, 1.4, 1.6],
                    "g": [0.2, 1.5, 3.0, 1.4, 0.5]
                },
                "output": 1.2
                }
            ],
            "tolerance": 0.05
            },
            {
            "problem": "transition_state_theory_rate",
            "function_name": "tst_rate_constant",
            "signature": "delta_G, T, kB, h",
            "description": "Compute reaction rate constant using transition state theory.",
            "cases": [
                {
                "type": "core",
                "input": {
                    "delta_G": 20.0,
                    "T": 298.15,
                    "kB": 1.0,
                    "h": 1.0
                },
                "output": 0.0023
                }
            ],
            "tolerance": 0.0005
            }





  ]
}
